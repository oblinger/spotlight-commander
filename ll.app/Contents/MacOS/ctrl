#!/usr/bin/env python
# AUTHOR:  Dan Oblinger  <code@oblinger.us>
# CREATE:  2015-01-10
# MODULE:  

import re
import os
import subprocess



CMD_DIR = '/ob/cmd'     # Bug.  should be located in home folder
APPLET_FOLDER = '/Applications/ll.app/Contents/MacOS'
SHORTCUTS = {'?':'usage'}

KEY_REGEX = re.compile('^# ([^:]*):(.*)$')

USAGE = \
"""

  CMD
    b  name                    captures current BROWSER url
    c  name type target        CREATE cap with 'name' that links to a 'target' of a given 'type'
    e  name                    EDIT
    f  name                    captures current finder item
    ?                          print USAGE information

    mv name newname
    rm name

    rebuild
    scan

    
  CAP TYPES  (Command APplication Types)
    app          launches 'target' application
    doc
    folder
    script       executes applet file itself as a script.
                 'target' is either 'python' or 'sh' denoting the interpter to use.
    sh           executes 'target' as a sh shell script line
"""



INFO_PLIST_BODY = \
"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>applet</string>
	<key>CFBundleIconFile</key>
	<string>applet</string>
	<key>CFBundleIdentifier</key>
	<string>com.apple.ScriptEditor.id.jdata7</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>jdata7</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>aplt</string>
	<key>LSMinimumSystemVersionByArchitecture</key>
	<dict>
		<key>x86_64</key>
		<string>10.6</string>
	</dict>
	<key>LSRequiresCarbon</key>
	<true/>
	<key>WindowState</key>
	<dict>
		<key>bundleDividerCollapsed</key>
		<true/>
		<key>bundlePositionOfDivider</key>
		<real>0</real>
		<key>dividerCollapsed</key>
		<false/>
		<key>eventLogLevel</key>
		<integer>2</integer>
		<key>name</key>
		<string>ScriptWindowState</string>
		<key>positionOfDivider</key>
		<real>389</real>
		<key>savedFrame</key>
		<string>50 32 700 640 0 0 1152 697 </string>
		<key>selectedTab</key>
		<string>description</string>
	</dict>
</dict>
</plist>
"""

APPLET_PREFIX = \
"""#!/usr/bin/osascript
do shell script   ("/usr/bin/env ruby " & (get POSIX path of (path to home folder)) as string & "cmd/_launcher.rb -x \\"" & (POSIX path of (path to me)) & "\\"") #$Cmd~File: v1.1-13.06.28
"""

PYTHON_LAUNCHER_PREFIX = \
"""#!/usr/bin/env python /Applications/ll.app/Contents/MacOS/launcher.py --launch
"""

def main():
    argv = os.sys.argv

    if len(argv)<2:
        os.sys.stdout.write('CMD> ')
        argv= ['cmd'] + raw_input().split()

    a1 = argv[1] if len(argv)>1 else ''
    a2 = argv[2] if len(argv)>2 else ''

    if a1[0:2]=='--':   base = a1[2:]
    elif a1[0:1]=='-':    base = a1[1:]
    else: base = a1
    base = SHORTCUTS.get(base) or base
    try:   fn=globals()['cmd_%s' % base]     # Try calling the appropriate 'cmd_...' function
    except KeyError:
        print "ERROR:  Unknown command '%s'" % a1
        return
    fn()




################################################################################
###  COMMANDS


def cmd_b():
    """Import doc link from BROWSER."""
    name = arg(1, 'Enter name for URL link> ')
    if not name: error('No name specified.')
    url = get_chrome_url()
    cap_set({NAME:name, ACTION:'url', TARGET:url})

    
def cmd_c():
    """Creates a new cmd app"""
    name   = arg(1, prompt='Name of cap to create> ', error_string='Name required.')
    action = arg(2, prompt='Cap action (%s)> ' % ', '.join(ACTIONS), error_string='Action required.')
    target = arg(3, prompt='Cap target> ', error_string='Target required')
    keys = {FOLDER:CMD_DIR, NAME:name, ACTION:action, TARGET:target}
    cap_set(keys)


def cmd_e():
    """Edits the specified command."""
    prefix = arg(1, prompt='Enter name to edit> ')
    path = cap_find(CMD_DIR, prefix, exactly_one=True)
    print("EDIT command.  prefix=%s.  path=%s" % (prefix, path))
    os.system('open -e "%s/Contents/MacOS/applet"' % path)


def cmd_f():
    """Import doc link from FINDER."""
    target_folder =  get_finder_path()[:-1]   # strip trailing '/'
    target_file = get_clipboard()
    target = target_folder+'/'+target_file
    name = os.path.splitext(target_file)[0]
    if not os.path.exists(target):
        error("Could not find file '%s'" % target)
    print "NAME:%s   TARGET:%s   DIR:%s  FILE:%s" % (name, target, target_folder, target_file)
    cap_set({NAME:name, ACTION:'doc', TARGET:target})
    cap_set({NAME:'J'+name, ACTION:'folder', TARGET:target_folder})

def cmd_x():
    name = arg(1, prompt='Enter name of command to execute')
    path = cap_find(CMD_DIR, name, exactly_one=True)
    os.system('open "%s"' % path)

def cmd_install():
    script = '%s/ctrl' % APPLET_FOLDER
    cap_set({NAME:'llb', ACTION:'sh', TARGET:'%s -b' % script, IO: 'console'})
    cap_set({NAME:'llc', ACTION:'sh', TARGET:'%s -c' % script, IO: 'console'})
    cap_set({NAME:'lle', ACTION:'sh', TARGET:'%s -e' % script, IO: 'console'})
    cap_set({NAME:'llf', ACTION:'sh', TARGET:'%s -f' % script})

def cmd_rebuild():
    folder = CMD_DIR
    if 'y'!=prompt('press "y" to delete and rebuild all CAPs under %s> ' % folder):
        return
    for cap in cap_get_all(folder):
        print "Rebuilding %r" % cap[NAME]
        cap_set(cap)

def cmd_rm():
    name =  arg(1, prompt='Enter name of command to remove')
    cap  = cap_get(cap_file_one(name))
    print '### Deleting CAP "%s"' % cap[NAME]
    cap_delete(cap)

def cmd_scan(folder=CMD_DIR+'/old'):
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        keys = cap_get(path)
        if not keys:
            print "Ignoring %s" % path
            continue
        if keys[ACTION] not in ['doc', 'folder', 'url', 'app']:  print cap_to_str(keys)
        #if keys:  cap_set(keys)
        #if keys:  scan_rebuild_cap(keys)
        #scan_process_file(keys)

def scan_rebuild_cap(keys):
    if keys[TYPE]=='webloc':
        pass
        cap_set(keys)




def cmd_test():
    print 'test it'
    cap_set({'folder':'/ob/data/MyDesk', 'name':'test3', 'action':'folder', 'target':'/ob/data'})

def cmd_usage():
    print USAGE
    os.sys.stdout.write('HIT RETURN TO EXIT')
    raw_input()
    



################################################################################
###   SUPPORT FUNCTIONS



##########################
###  CAP OPERATORS
###
###
### STANDARD KEYS IN A COMMAND APP FILE AND IN A 'CAP' MAP
FOLDER  = 'folder'   # REQ  the folder where this command resides
NAME    = 'name'     # REQ  the name of this cap  (it folder name with the .app removed)
TYPE    = 'type'     # REQ  'scpt' 'app' 'webloc'
ACTION  = 'action'   # REQ  'doc' 'folder' 'url'
TARGET  = 'target'   # REQ
BODY    = 'body'     # opt  List of text lines after the last key value pair
IO      = 'io'       # opt  non-null means that command should execute within a console window

ACTIONS = ['app', 'doc', 'folder', 'script', 'sh', 'url', 'nstr'] #, 'chrome']


def cap_get(path):
    """returns map of standard info plus the key value pairs from a cmd app."""
    try:
        name_ext = os.path.basename(path)
        name     = os.path.splitext(name_ext)[0]
        keys = {FOLDER:os.path.dirname(path), NAME:name}

        if os.path.isfile(path) and os.path.splitext(path)[1]=='.webloc':
            keys[TYPE]='webloc'
            with open(path, 'r') as f:
                lines = f.readlines()
            if not lines[5].startswith('        <string>') or not lines[5].endswith('</string>\n'):
                print lines
                print 'WARNING:  Could not read cap %r' % path
                return None
            target = lines[5][16:-10]
            keys[ACTION]='url'
            keys[TARGET]=target
            return keys

        if os.path.isfile(path) and os.path.splitext(path)[1]=='.scpt':
            keys[TYPE]='scpt'
            with open(path, 'r') as f:
                for line in f.readlines():
                    idx = line.find(':')
                    if idx!=-1 and line.startswith('# '):
                        k = line[2:idx].strip()
                        v = line[idx+1:].strip()
                        keys[k]=v
            return keys

        if os.path.isdir(path) and os.path.splitext(path)[1]=='.app':
            body = []
            keys[TYPE]='app'
            with open('%s/Contents/MacOS/applet' % path, 'r') as f:
                for line in f.readlines():
                    body.append(line[:-1] if line[-1:]=='\n' else line)
                    result = re.search(KEY_REGEX, line)
                    if result:
                        body = []
                        keys[result.group(1).strip()] = result.group(2).strip()
            if body[:1]==['']: body = body[1:]
            if body[-1:]==['\n']:  body = body[:-1]
            if len(body)!=0:  keys[BODY]=body
            return keys
    except:
        return None
    return None

def cap_file_one(prefix):
    return cap_find(CMD_DIR, prefix, exactly_one=True)

def cap_find(folder, prefix, **kwargs):
    """Returns list of paths to matching cap files.
    if 'only_one' then only one cap path is returned, and an error is generated
    if more or fewer than one cap is found."""
    exactly_one = kwargs.get('exactly_one')
    prefix = prefix.lower()
    paths = []
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        if name.lower().startswith(prefix) and cap_get(path):
            paths.append(path)
    if not exactly_one:
        return paths
    if len(paths)==0:
        error('Command App starting with "%s..." not found under %s' % (prefix, folder))
    if len(paths)>1:
        error('Required exactly one matching command for %s, but found %s' %
              (prefix, ', '.join(['/%s/' % os.path.basename(p) for p in paths])))
    return paths[0]




def cap_set(cap):
    print "### Creating Cmd App '%s' as a '%s' launcher..." % (cap[NAME], cap[ACTION])
    if not FOLDER in cap:  cap[FOLDER]=CMD_DIR
    if cap[ACTION] not in ACTIONS:
        error('Action %r must be one of: %s' % (cap[ACTION], ', '.join(ACTIONS)))
    cap_delete(cap)
    path = cap_path(cap)
    if not os.path.exists(path):
        os.makedirs('%s/Contents/MacOS' % path)
    write_file('%s/Contents/PkgInfo' % path, 'APPLaplt')
    write_file('%s/Contents/Info.plist' % path, INFO_PLIST_BODY)
    excludes   = ['body', 'type', 'folder', 'name', 'action', 'target', 'docstr', 'source', 'path']
    fixed_keys = '# action: %s\n# target: %s' % (cap['action'], cap['target'])
    other_keys = '\n'.join(['# %s: %s' % (k, v) for k,v in cap.items() if k not in excludes])
    contents = '%s\n%s\n%s\n' % (PYTHON_LAUNCHER_PREFIX, fixed_keys, other_keys)
    if BODY in cap:  contents = '%s%s\n' % (contents, '\n'.join(cap[BODY]))
    app_path = '%s/Contents/MacOS/applet' % path
    write_file(app_path, contents)
    os.system('chmod 755 "%s"' % app_path)

def cap_delete(cap):
    """Deletes a cap entry."""
    path = cap_path(cap)
    if os.path.exists(path):
        os.system('rm -r "%s"' % path)

def cap_get_all(folder):
    """Returns list of all cap maps for each cap under 'folder'"""
    cap_maps = []
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        cap = cap_get(path)
        if cap:   cap_maps.append(cap)
    return cap_maps

def cap_path(cap):
    """Returns fullpath for cap"""
    return '%s/%s.app' % (cap[FOLDER], cap[NAME])

def cap_to_str(cap):
    """Returns string summary of a cap's parameters."""
    return 'N:%s  A:%s  T:%s' % (cap[NAME], cap[ACTION], cap[TARGET])







###############################################################################
###   SUPPORT FUNCTIONS

def write_file(path, contents):
    with open(path,'w') as f:
        f.write(contents)


def arg(num, **kwargs):
    """Returns an argv value.  '1' is the first value after the command."""
    default_value = kwargs.get('default')
    prompt        = kwargs.get('prompt')
    error_string  = kwargs.get('error_string',
                               'Command is missing required argument #%s.' % num)
    if len(os.sys.argv)>num+1:
        return os.sys.argv[num+1]
    if 'prompt' in kwargs:
        value = raw_input(prompt)
        if value.strip() != '':
            return value
    if 'default' in kwargs:
        return default_value
    error(error_string)



def prompt(prompt):
    os.sys.stdout.write(prompt)
    return raw_input()


def error(err_str):
    raw_input("\n\nERROR: %s\n\n(press RETURN to exit)" % err_str)
    os._exit(1)


########### FROM OBLIB

str1 = \
"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>URL</key>
        <string>%s</string>
    </dict>
</plist>
"""

def create_webloc(path, url):
    """Creates PATH.webloc that causes browswer to open URL when clicked"""
    with open('%s.webloc' % path, 'w') as f:
        f.write(str1 % (url,))





def get_finder_path():
    """Returns path to folder in the top finder window"""
    return osa_fn('tell application "Finder" to return POSIX path of ((folder of the front window) as text)')

def get_chrome_url():
    """Returns URL in top tab of chrome browser"""
    return osa_fn("tell application \"Google Chrome\" to get URL of active tab of first window")

def send_keys(keys, using=None):
    """Sends 'keys' with specified modifier key settings to the current application:
          shift down, control down, option down, command down"""
    using = "using %s" % using if using else ''
    osa("Tell Application \"System Events\" to keystroke \"%s\" %s" % (keys, using))

def send_key(keycode):
    """Send applescript key code to application
       Download  'key codes' from app store to get codes"""
    osa("Tell Application \"System Events\" to key code %s" % (keycode,))

# from  http://www.macdrifter.com/2011/12/python-and-the-mac-clipboard.html
def get_clipboard():
    p = subprocess.Popen(['pbpaste'], stdout=subprocess.PIPE)
    retcode = p.wait()
    data = p.stdout.read()
    return data

def set_clipboard(data):
    p = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE)
    p.stdin.write(data)
    p.stdin.close()
    retcode = p.wait()

  
# Executes multi-line applescript.  (cannot contain single quote (') character)
def osa(*lines):
    """Executes multi-line applescript script"""
    os.system("osascript %s" % ' '.join(["-e '%s'" % line for line in lines]))


# Runs apple script lines and captures output
def osa_fn(*lines):
    """Executes multi-line applescript script, and returns the captured output."""
    cmd = ['/usr/bin/osascript']
    for l in lines:        cmd.append('-e'); cmd.append(l)
    p = subprocess.Popen(cmd, bufsize=0, stdout=subprocess.PIPE, stderr = subprocess.PIPE)
    stdout,stderr = p.communicate()
    return stdout.rstrip()



main()



"""


OLD



def scan_process_file(keys):
    path    = keys.get('path')
    name    = os.path.basename(path)
    base    = os.path.splitext(name)[0]
    newpath = '%s/%s' % (CMD_DIR, base)
    action  = keys.get('action')
    target  = keys.get('target')
    if action and action not in ['doc', 'folder', 'app']:
        print 'N:%s  A:%s   T:%s' % (base, keys.get('action'), keys.get('target'))
    if action=='url':
        print "Create URL shortcut   '%s'  to  '%s'" % (newpath, target)
        create_webloc('%s/%s' % (CMD_DIR, base), target)
        os.system('rm "%s"' % (path,))
    if action=='doc':
        pass
        #print "Doc shortcut  '%s' to '%s'" % (newpath, target)
def get_file_info(path):
    "Extracts the key value pairs from a cmd file.  Standard keys include:
       "
    keys = {'path':path}
    if os.path.isfile(path):
        keys['type']='file'
        with open(path, 'r') as f:
            for line in f.readlines():
                idx = line.find(':')
                if idx!=-1 and line.startswith('# '):
                    k = line[2:idx].strip()
                    v = line[idx+1:].strip()
                    keys[k]=v
    return keys


"""
