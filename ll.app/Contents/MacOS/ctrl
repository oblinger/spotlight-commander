#!/usr/bin/env python
# AUTHOR:  Dan Oblinger  <code@oblinger.us>
# CREATE:  2015-01-10
# MODULE:  

import re
import os
import subprocess
import textwrap

# todo:  installer, move /ob/cmd, add 'icon' to apps
# add readme


CMD_DIR = '%s/cmd' % os.getenv('HOME')
APPLET_FOLDER = '/Applications/ll.app/Contents/MacOS'
SHORTCUTS = {'b':'browser',  'c':'create', 'cp':'copy',  'e':'edit',
             'f':'finder',   'ls':'list',  'mv':'move',  'nb':'named_browser', 'nf':'named_finder',
             'rm':'remove',  'v':'view',
             'x':'execute',  '?':'usage'}

KEY_REGEX = re.compile('^# ([^:]*):(.*)$')

USAGE = \
"""
    *     COMMAND
    b   --browser       name                captures current BROWSER url
    c   --create        name type target    CREATE 'name' that links 'typed' 'target'
    cp  --copy          name newname        COPIES command to new name
        --debug         name                DEBUGS the execution of named command
    e   --edit          name                EDIT
    f   --finder        name                captures current finder item
        --install                           INSTALLS special commands
    ls  --list                              performs LS style list of commands
    mv  --move          name newname        MOVES command to new name
    nb  --named-browser name
    nf  --named-finder  name
        --rebuild                           scans all commands and REBUILDS them
    rm  --remove        name                REMOVES command
    v   --view          name
    x   --execute       name                EXECUTES 'name'd command
    ?   --usage                             prints this USAGE message
        --scan
        --test

 * NOTE: single or double character is a shortcut for the command to its right.


    
  CAP TYPES  (Command APplication Types)
    app          launches 'target' application
    doc
    folder
    nstr         opens name in notester
    script       executes applet file itself as a script
                 'target' specified either 'python' or 'sh' interpter
    sh           executes 'target' as a sh shell script line
"""


APPLET_PREFIX = \
"""#!/usr/bin/osascript
do shell script   ("/usr/bin/env ruby " & (get POSIX path of (path to home folder)) as string & "cmd/_launcher.rb -x \\"" & (POSIX path of (path to me)) & "\\"") #$Cmd~File: v1.1-13.06.28
"""

PYTHON_LAUNCHER_PREFIX = \
"""#!/usr/bin/env python /Applications/ll.app/Contents/MacOS/launcher.py --launch
"""


INFO_PLIST_BODY = \
"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>applet</string>
	<key>CFBundleIconFile</key>
	<string>applet</string>
	<key>CFBundleIdentifier</key>
	<string>com.apple.ScriptEditor.id.jdata7</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>jdata7</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>aplt</string>
	<key>LSMinimumSystemVersionByArchitecture</key>
	<dict>
		<key>x86_64</key>
		<string>10.6</string>
	</dict>
	<key>LSRequiresCarbon</key>
	<true/>
	<key>WindowState</key>
	<dict>
		<key>bundleDividerCollapsed</key>
		<true/>
		<key>bundlePositionOfDivider</key>
		<real>0</real>
		<key>dividerCollapsed</key>
		<false/>
		<key>eventLogLevel</key>
		<integer>2</integer>
		<key>name</key>
		<string>ScriptWindowState</string>
		<key>positionOfDivider</key>
		<real>389</real>
		<key>savedFrame</key>
		<string>50 32 700 640 0 0 1152 697 </string>
		<key>selectedTab</key>
		<string>description</string>
	</dict>
</dict>
</plist>
"""


def main():
    if not os.path.exists('%s/ctrl' % APPLET_FOLDER):
        print "Copy the app into the /Applications folder and re-run."
        error("Application must run from the /Applications folder.")
    argv = os.sys.argv
    if len(argv)<2:
        cmd_install(reinstall=False)
        argv= ['cmd'] + raw_input('CMD> ').split()
        if len(argv)<=1:
            os.sys.exit(0)
    a1 = argv[1] if len(argv)>1 else ''

    if a1[0:2]=='--':   base = a1[2:]
    elif a1[0:1]=='-':    base = a1[1:]
    else: base = a1
    base = SHORTCUTS.get(base) or base
    base = base.lower().replace('-', '_')
    try:   fn=globals()['cmd_%s' % base]     # Try calling the appropriate 'cmd_...' function
    except KeyError:
        print "ERROR:  Unknown command '%s'" % a1
        return
    fn()




################################################################################
###  COMMANDS

def cmd_browser(name=None):
    """Import doc link from BROWSER."""
    name = name or arg(1, 'Enter name for URL link')
    if not name: error('No name specified.')
    url = get_chrome_url()
    cap_set({NAME:name, ACTION:'url', TARGET:url})

def cmd_copy():
    name    = arg(1, prompt='Enter name of command to copy')
    newname = arg(2, prompt='Enter new destination name for copy')
    path = cap_find_one(name)
    cap  = cap_get(path)
    print '### Copying %r to %r' % (name, newname)
    cap[NAME] = newname
    cap_set(cap)

def cmd_create():
    """Creates a new cmd app"""
    name   = arg(1, prompt='Name of cap to create', error_string='Name required.')
    action = arg(2, prompt='Cap action (%s)' % ', '.join(ACTIONS), error_string='Action required.')
    target = arg(3, prompt='Cap target', error_string='Target required')
    keys = {FOLDER:CMD_DIR, NAME:name, ACTION:action, TARGET:target}
    cap_set(keys)

def cmd_debug():
    prefix = arg(1, prompt='Enter name to edit')
    path = cap_path( cap_get( cap_find_one(prefix) ) )
    print("### Debugging execution of CAP command %r" % path)
    os.system('/usr/bin/env python %s/launcher.py --debug --launch %s/Contents/MacOS/applet' % (APPLET_FOLDER, path))

def cmd_edit():
    """Edits the specified command."""
    prefix = arg(1, prompt='Enter name to edit')
    path = cap_find_one(prefix) + '/Contents/MacOS/applet'
    print("EDIT command.  prefix=%s.  path=%s" % (prefix, path))
    clean_file(path)
    os.system('open -e "%s"' % path)
    clean_file(path)

def clean_file(path):
    original = read_file(path)
    contents = original.replace('\xe2', "'")
    contents = contents.replace('\x80', "")
    contents = contents.replace('\x98', "")
    contents = contents.replace('\x99', "")
    contents = contents.encode('ascii', 'ignore')
    if original!=contents:
        write_file(path, contents)


def cmd_finder(name=None):
    """Import doc link from FINDER."""
    target_folder =  get_finder_path()[:-1]   # strip trailing '/'
    target_file = get_clipboard()
    target = target_folder+'/'+target_file
    name = name or os.path.splitext(target_file)[0]
    if not os.path.exists(target):
        error("Could not find file '%s'" % target)
    print "NAME:%s   TARGET:%s   DIR:%s  FILE:%s" % (name, target, target_folder, target_file)
    cap_set({NAME:name, ACTION:'doc', TARGET:target})
    cap_set({NAME:'J'+name, ACTION:'folder', TARGET:target_folder})

def cmd_install(reinstall=True):
    if not reinstall and os.path.exists(CMD_DIR):
        return
    print '\nCONFIGURING SPOTLIGHT-NINJA\n'
    script = '%s/ctrl' % APPLET_FOLDER
    if not os.path.exists(CMD_DIR):
        print 'Creating folder %r' % CMD_DIR
        os.makedirs(CMD_DIR)
    cap_set({NAME:'ll',   ACTION:'sh', TARGET:'%s'    % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llb',  ACTION:'sh', TARGET:'%s -b' % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llcp', ACTION:'sh', TARGET:'%s cp' % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llc',  ACTION:'sh', TARGET:'%s -c' % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'lle',  ACTION:'sh', TARGET:'%s -e' % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llf',  ACTION:'sh', TARGET:'%s -f' % script},                verbose=True)
    cap_set({NAME:'llls', ACTION:'sh', TARGET:'%s ls' % script, IO: 'pinned'},  verbose=True)
    cap_set({NAME:'llmv', ACTION:'sh', TARGET:'%s -e' % script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llnb', ACTION:'sh', TARGET:'%s -nb'% script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llnf', ACTION:'sh', TARGET:'%s -nf'% script, IO: 'console'}, verbose=True)
    cap_set({NAME:'llrm', ACTION:'sh', TARGET:'%s rm' % script, IO: 'console'}, verbose=True)

def cmd_list():
    prefix = arg(1, default='')
    names = [cap_get(path)[NAME].ljust(18) for path in cap_find_all(prefix)]
    print 'COMMANDS:\n%s\n\n' % textwrap.fill('  '.join(names),80)

def cmd_move():
    name    = arg(1, prompt='Enter name of command to move')
    newname = arg(2, prompt='Enter new destination name for move')
    path = cap_find_one(name)
    cap  = cap_get(path)
    print '### Moving %r to %r' % (name, newname)
    cap_delete(cap)
    cap[NAME] = newname
    cap_set(cap)

def cmd_named_browser():
    """Prompts user for name for link to URL in the top Chrome tab"""
    cmd_browser(prompt('Enter name for link to current Chrome URL'))

def cmd_named_finder():
    """Prompts user for name for link to document selected in finder"""
    cmd_finder(prompt('Enter name for link to file selected & clipboarded in Finder'))

def cmd_rebuild():
    folder = CMD_DIR
    if 'y'!=prompt('press "y" to delete and rebuild all CAPs under %s' % folder):
        return
    for cap in cap_get_all(folder):
        print "Rebuilding %r" % cap[NAME]
        cap_set(cap)

def cmd_remove():
    name =  arg(1, prompt='Enter name of command to remove')
    cap  =  cap_get(cap_find_one(name))
    print '### Deleting CAP "%s"' % cap[NAME]
    cap_delete(cap)

def cmd_view():
    name = arg(1, prompt='Enter name of command to view')
    path = cap_find_one(name)
    os.system('open "%s"' % path)

def cmd_execute():
    name = arg(1, prompt='Enter name of command to execute')
    path = cap_find_one(name)
    os.system('open "%s"' % path)

def cmd_test(folder=CMD_DIR+'/old'):
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        keys = cap_get(path)
        if not keys:
            print "Ignoring %s" % path
            continue
        if keys[ACTION] not in ['doc', 'folder', 'url', 'app']:  print cap_to_str(keys)
        #if keys:  cap_set(keys)
        #if keys:  scan_rebuild_cap(keys)
        #scan_process_file(keys)
def scan_rebuild_cap(keys):
    if keys[TYPE]=='webloc':
        pass
        cap_set(keys)

def cmd_usage():
    print USAGE
    os.sys.stdout.write('HIT RETURN TO EXIT')
    raw_input()
    



################################################################################
###   SUPPORT FUNCTIONS



##########################
###  CAP OPERATORS
###
###
### STANDARD KEYS IN A COMMAND APP FILE AND IN A 'CAP' MAP
FOLDER  = 'folder'   # REQ  the folder where this command resides
NAME    = 'name'     # REQ  the name of this cap  (it folder name with the .app removed)
TYPE    = 'type'     # REQ  'scpt' 'app' 'webloc'
ACTION  = 'action'   # REQ  'doc' 'folder' 'url'
TARGET  = 'target'   # REQ
BODY    = 'body'     # opt  List of text lines after the last key value pair
IO      = 'io'       # opt  non-null means that command should execute within a console window

ACTIONS = ['app', 'doc', 'folder', 'script', 'sh', 'url', 'nstr'] #, 'chrome']


def cap_get(path):
    """returns map of standard info plus the key value pairs from a cmd app."""
    try:
        name_ext = os.path.basename(path)
        name     = os.path.splitext(name_ext)[0]
        keys = {FOLDER:os.path.dirname(path), NAME:name}

        if os.path.isfile(path) and os.path.splitext(path)[1]=='.webloc':
            keys[TYPE]='webloc'
            with open(path, 'r') as f:
                lines = f.readlines()
            if not lines[5].startswith('        <string>') or not lines[5].endswith('</string>\n'):
                print lines
                print 'WARNING:  Could not read cap %r' % path
                return None
            target = lines[5][16:-10]
            keys[ACTION]='url'
            keys[TARGET]=target
            return keys

        if os.path.isfile(path) and os.path.splitext(path)[1]=='.scpt':
            keys[TYPE]='scpt'
            with open(path, 'r') as f:
                for line in f.readlines():
                    idx = line.find(':')
                    if idx!=-1 and line.startswith('# '):
                        k = line[2:idx].strip()
                        v = line[idx+1:].strip()
                        keys[k]=v
            return keys

        if os.path.isdir(path) and os.path.splitext(path)[1]=='.app':
            body = []
            keys[TYPE]='app'
            with open('%s/Contents/MacOS/applet' % path, 'r') as f:
                for line in f.readlines():
                    body.append(line[:-1] if line[-1:]=='\n' else line)
                    result = re.search(KEY_REGEX, line)
                    if result:
                        body = []
                        keys[result.group(1).strip()] = result.group(2).strip()
            #if body[:1]==['']: body = body[1:]
            if body[-1:]==['\n']:  body = body[:-1]
            if len(body)!=0:  keys[BODY]=body
            if keys.get(ACTION) not in ACTIONS:
                print('WARNING: Illegal action %r in %s' % (keys.get(ACTION), keys.get(NAME)))
            return keys
    except:
        return None
    return None

def cap_find_one(prefix, folder=CMD_DIR):
    paths = cap_find_all(prefix, folder)
    if len(paths)>1:
        paths2 = cap_find_all(prefix+'.')   # try looking for a case insensitive exact match
        if len(paths2)==1: paths = paths2
    if len(paths)==0:
        error('Command App starting with "%s..." not found under %s' % (prefix, folder))
    if len(paths)>1:
        error('Required exactly one matching command for %s, but found %s' %
              (prefix, ', '.join(['/%s/' % os.path.basename(p) for p in paths])))
    return paths[0]

def cap_find_all(prefix, folder=CMD_DIR):
    """Returns list of paths to matching cap files.
    if 'only_one' then only one cap path is returned, and an error is generated
    if more or fewer than one cap is found."""
    prefix = prefix.lower()
    paths = []
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        if name.lower().startswith(prefix) and cap_get(path):
            paths.append(path)
    return paths




def cap_set(cap, **kwargs):
    verbose = kwargs.get('verbose', True)
    if verbose: print "### Creating Cmd App '%s' as a '%s' launcher..." % (cap[NAME], cap[ACTION])
    if not FOLDER in cap:  cap[FOLDER]=CMD_DIR
    if cap[ACTION] not in ACTIONS:
        error('Action %r must be one of: %s' % (cap[ACTION], ', '.join(ACTIONS)))
    cap_delete(cap)
    path = cap_path(cap)
    if not os.path.exists(path):
        os.makedirs('%s/Contents/MacOS' % path)
    write_file('%s/Contents/PkgInfo' % path, 'APPLaplt')
    write_file('%s/Contents/Info.plist' % path, INFO_PLIST_BODY)
    excludes   = ['body', 'type', 'folder', 'name', 'action', 'target', 'docstr', 'source', 'path']
    fixed_keys = '# action: %s\n# target: %s' % (cap['action'], cap['target'])
    other_keys = '\n'.join(['# %s: %s' % (k, v) for k,v in cap.items() if k not in excludes])
    contents = '%s\n%s\n%s\n' % (PYTHON_LAUNCHER_PREFIX, fixed_keys, other_keys)
    if BODY in cap:  contents = '%s%s\n' % (contents, '\n'.join(cap[BODY]))
    app_path = '%s/Contents/MacOS/applet' % path
    write_file(app_path, contents)
    os.system('chmod 755 "%s"' % app_path)

def cap_delete(cap):
    """Deletes a cap entry."""
    path = cap_path(cap)
    if os.path.exists(path):
        os.system('rm -r "%s"' % path)

def cap_get_all(folder):
    """Returns list of all cap maps for each cap under 'folder'"""
    cap_maps = []
    for name in os.listdir(folder):
        path = '%s/%s' % (folder, name)
        cap = cap_get(path)
        if cap:   cap_maps.append(cap)
    return cap_maps

def cap_path(cap):
    """Returns fullpath for cap"""
    return '%s/%s.app' % (cap[FOLDER], cap[NAME])

def cap_to_str(cap):
    """Returns string summary of a cap's parameters."""
    return 'N:%s  A:%s  T:%s' % (cap[NAME], cap[ACTION], cap[TARGET])







###############################################################################
###   SUPPORT FUNCTIONS

def write_file(path, contents):
    with open(path,'w') as f:
        f.write(contents)

def read_file(path):
    with open(path,'r') as f:
        return f.read()


def arg(num, **kwargs):
    """Returns an argv value.  '1' is the first value after the command."""
    default_value = kwargs.get('default')
    prompt        = kwargs.get('prompt')
    error_string  = kwargs.get('error_string',
                               'Command is missing required argument #%s.' % num)
    if len(os.sys.argv)>num+1:
        return os.sys.argv[num+1]
    if 'prompt' in kwargs:
        value = raw_input(prompt+': ')
        if value.strip() != '':
            return value
    if 'default' in kwargs:
        return default_value
    error(error_string)



def prompt(prompt):
    os.sys.stdout.write(prompt+': ')
    return raw_input()


def error(err_str):
    raw_input("\n\nERROR: %s\n\n(press RETURN to exit)" % err_str)
    os._exit(1)


########### FROM OBLIB

str1 = \
"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>URL</key>
        <string>%s</string>
    </dict>
</plist>
"""

def create_webloc(path, url):
    """Creates PATH.webloc that causes browswer to open URL when clicked"""
    with open('%s.webloc' % path, 'w') as f:
        f.write(str1 % (url,))





def get_finder_path():
    """Returns path to folder in the top finder window"""
    return osa_fn('tell application "Finder" to return POSIX path of ((folder of the front window) as text)')

def get_chrome_url():
    """Returns URL in top tab of chrome browser"""
    return osa_fn("tell application \"Google Chrome\" to get URL of active tab of first window")

def send_keys(keys, using=None):
    """Sends 'keys' with specified modifier key settings to the current application:
          shift down, control down, option down, command down"""
    using = "using %s" % using if using else ''
    osa("Tell Application \"System Events\" to keystroke \"%s\" %s" % (keys, using))

def send_key(keycode):
    """Send applescript key code to application
       Download  'key codes' from app store to get codes"""
    osa("Tell Application \"System Events\" to key code %s" % (keycode,))

# from  http://www.macdrifter.com/2011/12/python-and-the-mac-clipboard.html
def get_clipboard():
    p = subprocess.Popen(['pbpaste'], stdout=subprocess.PIPE)
    retcode = p.wait()
    data = p.stdout.read()
    return data

def set_clipboard(data):
    p = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE)
    p.stdin.write(data)
    p.stdin.close()
    retcode = p.wait()

  
# Executes multi-line applescript.  (cannot contain single quote (') character)
def osa(*lines):
    """Executes multi-line applescript script"""
    os.system("osascript %s" % ' '.join(["-e '%s'" % line for line in lines]))


# Runs apple script lines and captures output
def osa_fn(*lines):
    """Executes multi-line applescript script, and returns the captured output."""
    cmd = ['/usr/bin/osascript']
    for l in lines:        cmd.append('-e'); cmd.append(l)
    p = subprocess.Popen(cmd, bufsize=0, stdout=subprocess.PIPE, stderr = subprocess.PIPE)
    stdout,stderr = p.communicate()
    return stdout.rstrip()



main()

